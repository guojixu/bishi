# 1
n = int(input())
s = set()
mp = {}
for i in range(1, n + 1):
    tmp = tuple(set(_ for _ in input().split()))
    if tmp in mp:
        print(mp[tmp], i)
    mp[tmp] = i



# 2
s = input()
n = len(s)
l = None
ans = None
for i in range(1, n // 2 + 1):
    if n % i == 0:
        x = n // i
        if x * s[:i] == s:
            l = x
            ans = s[:i]
            break
print("{}{}".format(l, ans))

# 3
from datetime import datetime

nums = [datetime.strptime(_, "%Y%m%d") for _ in input().split(",")]
nums.sort(key=lambda x: x.timestamp())
n = len(nums)
ans = 0
count = 0
for r in range(n):
    if r == 0 or (nums[r] - nums[r - 1]).days == 1:
        count += 1
        ans = max(ans, count)
    else:
        count = 1
print(ans)

# 4
def maxSumAfterPartitioning3(self, A, K) :
        n=len(A)
        res=[0]*(n+1)
        for i in range(1,n+1) :
            j=i-1
            mx=float("-inf")
            while i-j <= K and j >= 0 :
                #由于不知道lastSubA的大小，因此对lastSubA的所有可能都进行计算，取最大的
                mx=max(mx,A[j])
                res[i]=max(res[i],res[j]+mx*(i-j)) 
                j-=1
        return res[n]

作者：aabathur
链接：https://leetcode-cn.com/problems/partition-array-for-maximum-sum/solution/dong-tai-gui-hua-si-xiang-jie-jue-wen-ti-by-aabath/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

